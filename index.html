<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pixel Canvas</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #2c2c2c; font-family: sans-serif;
        }
        #canvas-container { width: 100%; height: 100%; cursor: grab; }
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            /* The canvas will be positioned by JavaScript */
            position: absolute;
        }
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c2c2c; display: flex; justify-content: center;
            align-items: center; color: white; font-size: 24px; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loader">Loading canvas...</div>
    <div id="canvas-container">
        <canvas id="pixel-canvas"></canvas>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const loader = document.getElementById('loader');
        const container = document.getElementById('canvas-container');

        // --- STATE ---
        let transform = { x: 0, y: 0, scale: 1 };
        let imageInfo = { width: 0, height: 0 };
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        let touch = { lastDist: 0, isPinching: false };

        // --- CORE RENDER LOGIC ---
        function render() {
            // Set canvas size to match the container, for sharp rendering
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Clear the entire visible canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply transformations (pan and zoom)
            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.scale, transform.scale);
            
            // Draw the pre-rendered image from the offscreen canvas
            ctx.drawImage(offscreenCanvas, 0, 0);
            
            ctx.restore();
        }

        // --- DATA FETCHING AND INITIALIZATION ---
        let offscreenCanvas; // This will hold our full, unscaled image

        async function initialize() {
            try {
                // Step 1: Fetch the small metadata file
                loader.textContent = 'Loading metadata...';
                const metaResponse = await fetch('canvas.json');
                if (!metaResponse.ok) throw new Error(`HTTP error! status: ${metaResponse.status}`);
                imageInfo = await metaResponse.json();

                // Step 2: Fetch the large binary pixel data file
                loader.textContent = 'Loading pixel data...';
                const pixelResponse = await fetch('canvas.bin');
                if (!pixelResponse.ok) throw new Error(`HTTP error! status: ${pixelResponse.status}`);
                const pixelBuffer = await pixelResponse.arrayBuffer();

                // Step 3: Create and draw to an offscreen canvas
                loader.textContent = 'Preparing image...';
                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = imageInfo.width;
                offscreenCanvas.height = imageInfo.height;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                const imageData = new ImageData(new Uint8ClampedArray(pixelBuffer), imageInfo.width, imageInfo.height);
                offscreenCtx.putImageData(imageData, 0, 0);

                // Step 4: Initial setup and first render
                centerAndFitImage();
                loader.style.display = 'none';
                requestAnimationFrame(render);

            } catch (error) {
                loader.textContent = "Error loading canvas. Check console.";
                console.error('Initialization failed:', error);
            }
        }
        
        // --- UTILITY FUNCTIONS ---
        function centerAndFitImage() {
            const scaleX = container.clientWidth / imageInfo.width;
            const scaleY = container.clientHeight / imageInfo.height;
            transform.scale = Math.min(scaleX, scaleY) * 0.9; // Fit with a 10% margin

            transform.x = (container.clientWidth - (imageInfo.width * transform.scale)) / 2;
            transform.y = (container.clientHeight - (imageInfo.height * transform.scale)) / 2;
        }

        function getTouchDistance(e) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- USER INPUT HANDLERS ---
        // Mouse Panning
        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            container.style.cursor = 'grabbing';
            lastPos = { x: e.clientX, y: e.clientY };
        });
        container.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastPos.x;
            const dy = e.clientY - lastPos.y;
            transform.x += dx;
            transform.y += dy;
            lastPos = { x: e.clientX, y: e.clientY };
            requestAnimationFrame(render);
        });
        container.addEventListener('mouseup', () => { isDragging = false; container.style.cursor = 'grab'; });
        container.addEventListener('mouseleave', () => { isDragging = false; container.style.cursor = 'grab'; });

        // Mouse Wheel Zooming
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 1.1;
            const oldScale = transform.scale;
            
            if (e.deltaY < 0) {
                transform.scale *= scaleAmount;
            } else {
                transform.scale /= scaleAmount;
            }
            transform.scale = Math.max(0.02, Math.min(transform.scale, 100));

            const mouseX = e.clientX - container.offsetLeft;
            const mouseY = e.clientY - container.offsetTop;
            
            transform.x = mouseX - (mouseX - transform.x) * (transform.scale / oldScale);
            transform.y = mouseY - (mouseY - transform.y) * (transform.scale / oldScale);

            requestAnimationFrame(render);
});

        // Touch Panning and Pinch-to-Zoom
        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                container.style.cursor = 'grabbing';
                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                isDragging = false;
                touch.isPinching = true;
                touch.lastDist = getTouchDistance(e);
            }
        });
        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                const dx = e.touches[0].clientX - lastPos.x;
                const dy = e.touches[0].clientY - lastPos.y;
                transform.x += dx;
                transform.y += dy;
                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                requestAnimationFrame(render);
            } else if (touch.isPinching && e.touches.length === 2) {
                const newDist = getTouchDistance(e);
                const scaleAmount = newDist / touch.lastDist;
                const oldScale = transform.scale;
                transform.scale *= scaleAmount;
                transform.scale = Math.max(0.02, Math.min(transform.scale, 100));
                
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                transform.x = centerX - (centerX - transform.x) * (transform.scale / oldScale);
                transform.y = centerY - (centerY - transform.y) * (transform.scale / oldScale);

                touch.lastDist = newDist;
                requestAnimationFrame(render);
            }
        });
        container.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) touch.isPinching = false;
            if (e.touches.length < 1) isDragging = false;
        });
        
        // --- START ---
        initialize();
        window.addEventListener('resize', () => {
            centerAndFitImage();
            requestAnimationFrame(render);
        });
    </script>
</body>
</html>
