<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Pixel Canvas</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #1d1f21; font-family: sans-serif;
            touch-action: none; /* Prevents default browser touch behaviors like pull-to-refresh */
        }
        #canvas-container { width: 100%; height: 100%; cursor: grab; position: relative; }
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: absolute;
            top: 0;
            left: 0;
        }
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1d1f21; display: flex; justify-content: center;
            align-items: center; color: white; font-size: 24px; z-index: 100;
        }
        /* --- NEW UI STYLES --- */
        #info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 50;
            transition: opacity 0.3s;
        }
        #toggle-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid #555;
            border-radius: 50%;
            font-size: 20px;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="loader">Loading...</div>
    <div id="canvas-container">
        <canvas id="pixel-canvas"></canvas>
    </div>
    
    <!-- NEW UI ELEMENTS -->
    <div id="info-panel">
        <span id="canvas-size"></span>
    </div>
    <div id="toggle-info">i</div>


    <script>
        // --- SETUP ---
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const loader = document.getElementById('loader');
        const container = document.getElementById('canvas-container');
        // NEW UI ELEMENT REFERENCES
        const infoPanel = document.getElementById('info-panel');
        const canvasSizeSpan = document.getElementById('canvas-size');
        const toggleInfoBtn = document.getElementById('toggle-info');

        // --- STATE ---
        let transform = { x: 0, y: 0, scale: 1 };
        let imageInfo = { width: 0, height: 0, tileSize: 0 };
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        let touch = { lastDist: 0, isPinching: false };
        
        // --- TILE MANAGEMENT ---
        const tileCache = {};
        const loadingTiles = new Set();

        // --- CORE RENDER LOGIC ---
        function render() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            ctx.fillStyle = '#1d1f21';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!imageInfo.tileSize) return;

            const { tileSize } = imageInfo;
            const view = {
                x: -transform.x / transform.scale,
                y: -transform.y / transform.scale,
                w: canvas.width / transform.scale,
                h: canvas.height / transform.scale
            };

            const startCol = Math.floor(view.x / tileSize);
            const endCol = Math.ceil((view.x + view.w) / tileSize);
            const startRow = Math.floor(view.y / tileSize);
            const endRow = Math.ceil((view.y + view.h) / tileSize);

            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.scale, transform.scale);
            
            for (let row = startRow; row < endRow; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const tileX = col * tileSize;
                    const tileY = row * tileSize;
                    
                    if (tileX >= imageInfo.width || tileY >= imageInfo.height) continue;

                    const tileId = `${tileY}_${tileX}`;
                    
                    if (tileCache[tileId]) {
                        ctx.drawImage(tileCache[tileId], tileX, tileY);
                    } else {
                        loadTile(tileY, tileX);
                    }
                }
            }
            ctx.restore();
        }

        async function loadTile(row, col) {
            const tileId = `${row}_${col}`;
            if (loadingTiles.has(tileId)) return;

            try {
                loadingTiles.add(tileId);
                const response = await fetch(`tiles/tile_${row}_${col}.bin`);
                if (!response.ok) return; // Fail silently if tile not found
                
                const pixelBuffer = await response.arrayBuffer();
                const imageData = new ImageData(new Uint8ClampedArray(pixelBuffer), imageInfo.tileSize, imageInfo.tileSize);
                
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = imageInfo.tileSize;
                tileCanvas.height = imageInfo.tileSize;
                tileCanvas.getContext('2d').putImageData(imageData, 0, 0);

                tileCache[tileId] = tileCanvas;
                requestAnimationFrame(render);

            } catch (error) {
                console.error(`Failed to load tile ${tileId}:`, error);
            } finally {
                loadingTiles.delete(tileId);
            }
        }

        // --- INITIALIZATION ---
        async function initialize() {
            try {
                loader.textContent = 'Loading manifest...';
                const metaResponse = await fetch('manifest.json');
                if (!metaResponse.ok) throw new Error(`HTTP error! status: ${metaResponse.status}`);
                imageInfo = await metaResponse.json();

                // --- NEW: Update UI with info ---
                canvasSizeSpan.textContent = `${imageInfo.width} x ${imageInfo.height} px`;

                centerAndFitImage();
                loader.style.display = 'none';
                requestAnimationFrame(render);

            } catch (error) {
                loader.textContent = "Error loading canvas. Check console.";
                console.error('Initialization failed:', error);
            }
        }
        
        function centerAndFitImage() {
            const scaleX = container.clientWidth / imageInfo.width;
            const scaleY = container.clientHeight / imageInfo.height;
            transform.scale = Math.min(scaleX, scaleY) * 0.9;
            transform.x = (container.clientWidth - (imageInfo.width * transform.scale)) / 2;
            transform.y = (container.clientHeight - (imageInfo.height * transform.scale)) / 2;
        }

        // --- USER INPUT HANDLERS (MOUSE & TOUCH) ---
        function handlePanStart(x, y) { isDragging = true; container.style.cursor = 'grabbing'; lastPos = { x, y }; }
        function handlePanMove(x, y) { if (!isDragging) return; const dx = x - lastPos.x; const dy = y - lastPos.y; transform.x += dx; transform.y += dy; lastPos = { x, y }; requestAnimationFrame(render); }
        function handlePanEnd() { isDragging = false; container.style.cursor = 'grab'; }
        function handleZoom(scaleAmount, centerX, centerY) { const oldScale = transform.scale; transform.scale *= scaleAmount; transform.scale = Math.max(0.02, Math.min(transform.scale, 100)); transform.x = centerX - (centerX - transform.x) * (transform.scale / oldScale); transform.y = centerY - (centerY - transform.y) * (transform.scale / oldScale); requestAnimationFrame(render); }

        container.addEventListener('mousedown', (e) => handlePanStart(e.clientX, e.clientY));
        container.addEventListener('mousemove', (e) => handlePanMove(e.clientX, e.clientY));
        container.addEventListener('mouseup', handlePanEnd);
        container.addEventListener('mouseleave', handlePanEnd);
        container.addEventListener('wheel', (e) => { e.preventDefault(); const scaleAmount = e.deltaY < 0 ? 1.1 : 1 / 1.1; handleZoom(scaleAmount, e.clientX, e.clientY); });
        container.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { handlePanStart(e.touches[0].clientX, e.touches[0].clientY); } else if (e.touches.length === 2) { isDragging = false; touch.isPinching = true; touch.lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); } });
        container.addEventListener('touchmove', (e) => { e.preventDefault(); if (e.touches.length === 1 && isDragging) { handlePanMove(e.touches[0].clientX, e.touches[0].clientY); } else if (e.touches.length === 2 && touch.isPinching) { const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); const scaleAmount = newDist / touch.lastDist; const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2; const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2; handleZoom(scaleAmount, centerX, centerY); touch.lastDist = newDist; } });
        container.addEventListener('touchend', (e) => { if (e.touches.length < 2) touch.isPinching = false; if (e.touches.length < 1) handlePanEnd(); });
        
        // --- NEW: Toggle info panel visibility ---
        toggleInfoBtn.addEventListener('click', () => {
            const isVisible = infoPanel.style.opacity !== '0';
            infoPanel.style.opacity = isVisible ? '0' : '1';
        });

        // --- START ---
        initialize();
        window.addEventListener('resize', () => { centerAndFitImage(); requestAnimationFrame(render); });
    </script>
</body>
</html>
